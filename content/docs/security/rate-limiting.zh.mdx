---
title: 速率限制
description: 使用速率限制保护您的 API 免受滥用
---

# 速率限制

实施速率限制以防止滥用并保护您的基础设施。

## 为什么需要速率限制？

- 防止 DDoS 攻击
- 防止暴力破解攻击
- 控制 API 成本
- 确保公平使用
- 提高系统稳定性

## Upstash Redis

使用 Upstash 实现无服务器友好的速率限制。

### 设置

```bash
pnpm add @upstash/ratelimit @upstash/redis
```

配置环境变量：

```bash
UPSTASH_REDIS_REST_URL=https://...
UPSTASH_REDIS_REST_TOKEN=...
```

### 基本实现

```typescript
// lib/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

export const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '10 s'),
  analytics: true,
});
```

### API 路由保护

```typescript
// app/api/protected/route.ts
import { ratelimit } from '@/lib/rate-limit';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  const ip = request.headers.get('x-forwarded-for') ?? 'anonymous';

  const { success, limit, remaining, reset } = await ratelimit.limit(ip);

  if (!success) {
    return NextResponse.json(
      {
        error: '请求过多',
        limit,
        remaining,
        reset,
      },
      {
        status: 429,
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': reset.toString(),
        },
      }
    );
  }

  // 处理请求
  return NextResponse.json({ success: true });
}
```

## 不同策略

### 固定窗口

```typescript
export const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.fixedWindow(10, '60 s'),
});
```

### 滑动窗口

```typescript
export const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '60 s'),
});
```

### 令牌桶

```typescript
export const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.tokenBucket(10, '60 s', 100),
});
```

## 每用户速率限制

```typescript
import { auth } from '@/lib/auth';

export async function POST(request: Request) {
  const session = await auth();

  if (!session) {
    return NextResponse.json({ error: '未授权' }, { status: 401 });
  }

  const identifier = `user:${session.user.id}`;
  const { success } = await ratelimit.limit(identifier);

  if (!success) {
    return NextResponse.json(
      { error: '请求过多' },
      { status: 429 }
    );
  }

  // 处理请求
}
```

## 不同层级的不同限制

```typescript
// lib/rate-limit.ts
export const freeTierLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '1 h'),
});

export const proTierLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(100, '1 h'),
});

export const enterpriseLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(1000, '1 h'),
});
```

```typescript
export async function POST(request: Request) {
  const session = await auth();
  const user = await db.user.findUnique({
    where: { id: session.user.id },
  });

  let limiter;
  switch (user?.tier) {
    case 'pro':
      limiter = proTierLimit;
      break;
    case 'enterprise':
      limiter = enterpriseLimit;
      break;
    default:
      limiter = freeTierLimit;
  }

  const { success } = await limiter.limit(`user:${user.id}`);

  if (!success) {
    return NextResponse.json(
      { error: '您的层级请求过多' },
      { status: 429 }
    );
  }

  // 处理请求
}
```

## 中间件速率限制

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { ratelimit } from '@/lib/rate-limit';

export async function middleware(request: NextRequest) {
  const ip = request.ip ?? 'anonymous';

  // 仅对 API 路由进行速率限制
  if (request.nextUrl.pathname.startsWith('/api/')) {
    const { success } = await ratelimit.limit(ip);

    if (!success) {
      return NextResponse.json(
        { error: '请求过多' },
        { status: 429 }
      );
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: '/api/:path*',
};
```

## 魔术链接速率限制

防止魔术链接垃圾邮件：

```typescript
// app/api/auth/magic-link/route.ts
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const magicLinkLimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(3, '1 h'),
});

export async function POST(request: Request) {
  const { email } = await request.json();

  const { success } = await magicLinkLimit.limit(email);

  if (!success) {
    return NextResponse.json(
      {
        error: '魔术链接请求过多。请稍后再试。',
      },
      { status: 429 }
    );
  }

  // 发送魔术链接
}
```

## 密码重置速率限制

```typescript
const passwordResetLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(3, '1 h'),
});

export async function POST(request: Request) {
  const { email } = await request.json();

  const { success } = await passwordResetLimit.limit(email);

  if (!success) {
    // 出于安全考虑，不要泄露是否达到速率限制
    return NextResponse.json({
      message: '如果存在账户，将发送重置链接。',
    });
  }

  // 发送密码重置电子邮件
}
```

## 错误响应格式

```typescript
interface RateLimitError {
  error: string;
  limit: number;
  remaining: number;
  reset: number; // Unix 时间戳
}

// 客户端可以使用重置时间来显示倒计时
const secondsUntilReset = Math.ceil((reset - Date.now()) / 1000);
```

## 客户端处理

```tsx
'use client';

import { useState } from 'react';

export function RateLimitedForm() {
  const [error, setError] = useState<string | null>(null);
  const [retryAfter, setRetryAfter] = useState<number | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      const response = await fetch('/api/endpoint', {
        method: 'POST',
        body: JSON.stringify(data),
      });

      if (response.status === 429) {
        const data = await response.json();
        const secondsUntilReset = Math.ceil((data.reset - Date.now()) / 1000);
        setRetryAfter(secondsUntilReset);
        setError(`请求过多。请在 ${secondsUntilReset} 秒后重试。`);
        return;
      }

      // 处理成功
    } catch (error) {
      console.error('错误:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && <div className="text-red-500">{error}</div>}
      {/* 表单字段 */}
      <button type="submit" disabled={retryAfter !== null}>
        提交
      </button>
    </form>
  );
}
```

## 监控

跟踪速率限制命中：

```typescript
import * as Sentry from '@sentry/nextjs';

const { success, limit, remaining } = await ratelimit.limit(identifier);

if (!success) {
  Sentry.captureMessage('速率限制超出', {
    level: 'warning',
    extra: {
      identifier,
      limit,
      remaining,
    },
  });
}
```

## 最佳实践

1. **不同端点的不同限制**：关键端点需要更严格的限制
2. **基于用户的限制**：对已验证用户更宽松
3. **清晰的错误消息**：告知用户何时可以重试
4. **返回速率限制头**：帮助客户端实现退避
5. **监控和调整**：根据实际使用情况审查限制
6. **白名单受信任 IP**：允许内部服务
7. **使用滑动窗口**：比固定窗口更平滑的速率限制

## 后续步骤

- 配置 [安全头](/docs/security/headers)
- 实施 [输入验证](/docs/security/validation)
- 了解 [错误处理](/docs/features/error-handling)

