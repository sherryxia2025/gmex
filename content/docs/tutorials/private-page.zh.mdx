---
title: 私有页面
description: 创建需要身份验证的页面
---

# 私有页面

学习如何创建需要用户身份验证的页面。

## 服务器端保护

保护页面的最安全方法是在服务器端。

### 基本受保护页面

```tsx
// app/[locale]/dashboard/page.tsx
import { auth } from '@/lib/auth';
import { redirect } from 'next/navigation';

export default async function DashboardPage() {
  const session = await auth();

  if (!session) {
    redirect('/');
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold">仪表板</h1>
      <p>欢迎回来，{session.user.name}！</p>
    </div>
  );
}
```

### 受保护布局

使用共享布局保护多个页面：

```tsx
// app/[locale]/dashboard/layout.tsx
import { auth } from '@/lib/auth';
import { redirect } from 'next/navigation';
import { ReactNode } from 'react';

export default async function DashboardLayout({
  children,
}: {
  children: ReactNode;
}) {
  const session = await auth();

  if (!session) {
    redirect('/');
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <nav className="bg-white shadow">
        <div className="container mx-auto px-4 py-4">
          <p>已登录为 {session.user.email}</p>
        </div>
      </nav>
      <main>{children}</main>
    </div>
  );
}
```

## 客户端保护

用于动态内容和交互性：

```tsx
'use client';

import { useSession } from '@/lib/auth-client';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';
import { Spinner } from '@/components/ui/spinner';

export default function ProfilePage() {
  const { data: session, isPending } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (!isPending && !session) {
      router.push('/');
    }
  }, [session, isPending, router]);

  if (isPending) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Spinner />
      </div>
    );
  }

  if (!session) {
    return null;
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-4">个人资料</h1>
      <div className="bg-white rounded-lg shadow p-6">
        <p><strong>姓名:</strong> {session.user.name}</p>
        <p><strong>电子邮件:</strong> {session.user.email}</p>
      </div>
    </div>
  );
}
```

## 基于角色的访问控制

实施基于角色的权限：

```tsx
// app/[locale]/admin/page.tsx
import { auth } from '@/lib/auth';
import { redirect } from 'next/navigation';
import { db } from '@/prisma';

export default async function AdminPage() {
  const session = await auth();

  if (!session) {
    redirect('/');
  }

  // 检查用户是否具有管理员角色
  const user = await db.user.findUnique({
    where: { id: session.user.id },
  });

  if (user?.role !== 'ADMIN') {
    redirect('/dashboard');
  }

  return (
    <div>
      <h1>管理面板</h1>
      {/* 管理员内容 */}
    </div>
  );
}
```

## 中间件保护

在中间件级别保护路由：

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const session = request.cookies.get('session');

  // 保护仪表板路由
  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    if (!session) {
      return NextResponse.redirect(new URL('/', request.url));
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/dashboard/:path*', '/admin/:path*'],
};
```

## 最佳实践

1. **始终在服务器上验证**：客户端检查可以被绕过
2. **使用中间件进行路由保护**：比每页检查更高效
3. **实施基于角色的访问**：并非所有经过身份验证的用户都应访问所有内容
4. **处理加载状态**：在检查身份验证时提供反馈
5. **适当重定向**：将用户发送到登录页面或适当的页面

## 后续步骤

- 设置 [Stripe 订阅](/docs/tutorials/stripe-subscriptions)
- 了解 [API 保护](/docs/tutorials/api-call)
